package com.bc.calvalus.reporting.code;import com.bc.calvalus.commons.CalvalusLogger;import com.bc.calvalus.reporting.common.Report;import com.bc.calvalus.reporting.common.Reporter;import com.bc.calvalus.reporting.common.ReportingConnection;import com.bc.calvalus.reporting.common.StatusHandler;import java.io.FileReader;import java.io.IOException;import java.io.Reader;import java.util.Properties;import java.util.concurrent.ScheduledThreadPoolExecutor;import java.util.logging.Level;import java.util.logging.Logger;/** * @author Hans Permana */public class CodeReporting implements Reporter {    private static final Logger LOGGER = CalvalusLogger.getLogger();    private final String configPath;    private final Properties config = new Properties();    private ScheduledThreadPoolExecutor timer = new ScheduledThreadPoolExecutor(1);    private ReportingConnection reportingConnection = new ReportingConnection(this);    private AccountingJmsConnection accountingJmsConnection = new AccountingJmsConnection(this);    private StatusHandler statusHandler = new StatusHandler(this);    @Override    public String getName() {        return "code";    }    @Override    public Properties getConfig() {        return config;    }    @Override    public void process(Report report) {        switch (report.state) {        case NOT_YET_RETRIEVED:            getStatusHandler().setRunning(report.job, report.creationTime);        case NEW:            getReportingConnection().retrieveSingle(report);            break;        case NOT_YET_ACCOUNTED:            getStatusHandler().setRunning(report.job, report.creationTime);        case RETRIEVED:            try {                getAccountingJmsConnection().send(report);            } catch (Exception exception) {                LOGGER.log(Level.SEVERE, "Unable to send the report", exception);            }            break;        default:            LOGGER.warning("report " + report.job + " in state " + report.state + " cannot be handled");        }    }    @Override    public StatusHandler getStatusHandler() {        return statusHandler;    }    @Override    public ScheduledThreadPoolExecutor getTimer() {        return timer;    }    @Override    public void setTimer(ScheduledThreadPoolExecutor timer) {        this.timer = timer;    }    private ReportingConnection getReportingConnection() {        return reportingConnection;    }    private AccountingJmsConnection getAccountingJmsConnection() {        return accountingJmsConnection;    }    private CodeReporting(String configPath) {        this.configPath = configPath;    }    public static void main(String[] args) {        try {            new CodeReporting(args.length > 0 ? args[0] : "etc/code.properties").run();        } catch (IOException e) {            LOGGER.severe("CodeReporting start failed: " + e.getMessage());            System.exit(1);        }    }    private void run() throws IOException {        initConfiguration();        statusHandler.initReport();        getReportingConnection().pollReportingServer();        getAccountingJmsConnection().close();    }    private void initConfiguration() throws IOException {        try {            try (Reader in = new FileReader(configPath)) {                config.load(in);            }        } catch (IOException e) {            throw new IOException("failed to read configuration from " + configPath + ": " + e.getMessage(), e);        }    }}