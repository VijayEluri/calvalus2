package com.bc.calvalus.reporting.code;import com.bc.calvalus.commons.CalvalusLogger;import com.bc.calvalus.reporting.code.reader.JobDetail;import com.bc.calvalus.reporting.code.reader.ReadJobDetail;import com.bc.calvalus.reporting.code.sender.ProcessedMessage;import com.bc.calvalus.reporting.code.sender.SendMessage;import com.bc.calvalus.reporting.common.Report;import com.bc.calvalus.reporting.common.Reporter;import com.bc.calvalus.reporting.common.ReportingConnection;import com.bc.calvalus.reporting.common.StatusHandler;import com.bc.calvalus.reporting.common.WpsConnection;import java.io.FileReader;import java.io.IOException;import java.io.Reader;import java.util.List;import java.util.Properties;import java.util.concurrent.ScheduledThreadPoolExecutor;import java.util.logging.Logger;import java.util.stream.Collectors;/** * @author Hans Permana */public class CodeReporting implements Reporter {    private static final Logger LOGGER = CalvalusLogger.getLogger();    private final String configPath;    private final Properties config = new Properties();    private ScheduledThreadPoolExecutor timer = new ScheduledThreadPoolExecutor(1);    private ReportingConnection reportingConnection = new ReportingConnection(this);    private AccountingJmsConnection accountingJmsConnection = new AccountingJmsConnection(this);    private WpsConnection wpsConnection = new WpsConnection(this);    private StatusHandler statusHandler = new StatusHandler(this);    @Override    public String getName() {        return "code";    }    @Override    public Properties getConfig() {        return config;    }    @Override    public void process(Report report) {        switch (report.state) {        case NOT_YET_RETRIEVED:            getStatusHandler().setRunning(report.job, report.creationTime);        case NEW:            getReportingConnection().retrieve(report);            break;        case NOT_YET_ACCOUNTED:            getStatusHandler().setRunning(report.job, report.creationTime);        case RETRIEVED:            getAccountingJmsConnection().send(report);            break;        default:            LOGGER.warning("report " + report.job + " in state " + report.state + " cannot be handled");        }    }    @Override    public StatusHandler getStatusHandler() {        return statusHandler;    }    @Override    public ScheduledThreadPoolExecutor getTimer() {        return timer;    }    @Override    public void setTimer(ScheduledThreadPoolExecutor timer) {        this.timer = timer;    }    private ReportingConnection getReportingConnection() {        return reportingConnection;    }    private AccountingJmsConnection getAccountingJmsConnection() {        return accountingJmsConnection;    }    private CodeReporting(String configPath) {        this.configPath = configPath;    }    public static void main(String[] args) {        try {            new CodeReporting(args.length > 0 ? args[0] : "etc/code.properties").run();        } catch (IOException e) {            LOGGER.severe("CodeReporting start failed: " + e.getMessage());            System.exit(1);        }    }    private void run() throws IOException {        initConfiguration();        statusHandler.initReport();        wpsConnection.run();        ReadJobDetail readJobDetail = new ReadJobDetail();        List<JobDetail> jobDetail = readJobDetail.getJobDetail();        if (jobDetail.size() <= 0) {            LOGGER.info(String.format("Job details between %s is empty %s", readJobDetail.startDateTime().toString()));            return;        }        ProcessedMessage[] processedMessage = transformProcessedMessage(jobDetail);        SendMessage sendMessage = new SendMessage(processedMessage);        sendMessage.send();    }    private void initConfiguration() throws IOException {        try {            try (Reader in = new FileReader(configPath)) {                config.load(in);            }        } catch (IOException e) {            throw new IOException("failed to read configuration from " + configPath + ": " + e.getMessage(), e);        }    }    private static ProcessedMessage[] transformProcessedMessage(List<JobDetail> jobDetails) {        List<ProcessedMessage> collect = jobDetails.stream().map(p -> new ProcessedMessage(p))                    .collect(Collectors.toList());        return collect.toArray(new ProcessedMessage[0]);    }}