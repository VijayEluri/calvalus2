package com.bc.calvalus.code.de;import com.bc.calvalus.code.de.reader.JobDetail;import com.bc.calvalus.code.de.reader.ReadJobDetail;import com.bc.calvalus.code.de.sender.NullProcessedMessage;import com.bc.calvalus.code.de.sender.ProcessedMessage;import com.bc.calvalus.code.de.sender.SendMessage;import com.bc.calvalus.commons.CalvalusLogger;import com.bc.wps.utilities.PropertiesWrapper;import java.io.IOException;import java.util.List;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.logging.Level;import java.util.logging.Logger;import java.util.stream.Collectors;import org.apache.log4j.BasicConfigurator;import static java.util.concurrent.TimeUnit.SECONDS;/** * @author muhammad.bc. */public class Launcher implements Runnable {    private static Logger logger = CalvalusLogger.getLogger();    public Launcher() {        loadProperties();        int delaySeconds = Integer.parseInt(PropertiesWrapper.get("submit.time.interval"));        ScheduledExecutorService scheduledExecutorService = Executors.newSingleThreadScheduledExecutor();        scheduledExecutorService.scheduleWithFixedDelay(this, 0, delaySeconds, SECONDS);    }    @Override    public void run() {        ReadJobDetail readJobDetail = new ReadJobDetail();        List<JobDetail> jobDetail = readJobDetail.getJobDetail();        if (jobDetail.size() <= 0) {            logger.info(String.format("Job details between %s is empty %s", readJobDetail.startDateTime()));            return;        }        ProcessedMessage[] processedMessage = transformProcessedMessage(jobDetail);        SendMessage sendMessage = new SendMessage(processedMessage);        sendMessage.send();    }    static void loadProperties() {        try {            PropertiesWrapper.loadConfigFile("calvalus-code-de.properties");            BasicConfigurator.configure();            logger.info("Load property setting....");        } catch (IOException e) {            logger.log(Level.SEVERE, e.getMessage());        }    }    public static ProcessedMessage[] createEmpty() {        return new ProcessedMessage[]{new NullProcessedMessage()};    }    public static ProcessedMessage[] transformProcessedMessage(List<JobDetail> jobDetails) {        List<ProcessedMessage> collect = jobDetails.stream().map(p -> new ProcessedMessage(p))                .collect(Collectors.toList());        return collect.toArray(new ProcessedMessage[0]);    }    public static void main(String[] args) {        Launcher launcher = new Launcher();    }}